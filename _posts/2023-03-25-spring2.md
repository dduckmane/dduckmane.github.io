---
layout: single
title:  "싱글톤과 의존관계 주입"
categories: Spring
tag: [개념]

author_profile: false
sidebar:
    nav: "counts"
---

# 스프링과 싱글톤 & 의존관계 주입

## 스프링과 싱글톤

- 객체 인스턴스를 싱글톤으로 관리한다.
    
    여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안된다.무상태(stateless)로 설계해야 한다!
    
- @Configuration 을 붙이면 바이트코드를 조작하는 CGLIB 기술을 사용해서 싱글톤을 보장
- @Bean만 사용해도 스프링 빈으로 등록되지만, 싱글톤을 보장하지 않는다.

[CGLIB 기술]

- 바이트 코드를 조작해서 동적으로 프록시를 생성한다.

## 컴포넌트 스캔과 의존관계 자동 주입

- 컴포넌트 스캔은 이름 그대로 @Component 애노테이션이 붙은 클래스를 스캔해서 스프링 빈으로 등록한다
- @Autowired 를 지정하면, 스프링 컨테이너가 자동으로 해당 스프링 빈을 찾아서 주입한다.

## 생성자 주입 사용 시 장점

- 순환 참조 방지
    - 순환 참조는 A -> B를 참조하면서, B -> A를 참조하는 경우 발생하는 문제
    - 생성자 주입은 먼저 빈을 생성하지 않고 주입하려는 빈을 찾는다. 그래서 실행시 바로 순환참조 에러가 뜨면서 찾을 수 있다.
- final 선언이 가능
    - 생성자 주입 시, 의존성 주입이 클래스 인스턴스화 중에 시작되므로 final을 선언할 수 있다. 따라서 객체를 변경이 불가능하게 할 수 있다.
- 생성자 주입은 객체를 생성할 때 딱 1번만 호출되므로 이후에 호출되는 일이 없다. 따라서 불변하게 설계할 수 있다.
- 수정자 주입을 사용하면, setXxx 메서드를 public으로 열어두어야 한다.누군가 실수로 변경할 수 도 있고, 변경하면 안되는 메서드를 열어두는 것은 좋은 설계 방법이 아니다.
- 필드 주입 방식은 di 컨테이너 없이는 동작하지 못하므로 단위 테스트를 할 수 없다.

[순환 참조]

- 서로 다른 빈들이 서로 참조하여서 서로에게 주입되는 현상


